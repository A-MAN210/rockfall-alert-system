# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I6KeQg8fuXD-wdoTsJVVbXmKqOFVE16O
"""

!pip install pandas numpy scikit-learn xgboost tensorflow shap imbalanced-learn matplotlib folium

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE
from xgboost import XGBClassifier
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import shap
import matplotlib.pyplot as plt
import folium
from folium import plugins
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Simulate Data (as in prototype)
def simulate_data(n_samples=5000, n_timesteps=24):  # Smaller for Colab speed
    np.random.seed(42)
    x, y = np.meshgrid(np.linspace(0, 100, 100), np.linspace(0, 100, 100))
    coords = np.column_stack([x.ravel()[:n_samples], y.ravel()[:n_samples]])  # Subset for speed

    slope = np.random.uniform(20, 60, n_samples)
    aspect = np.random.uniform(0, 360, n_samples)
    elevation = np.random.uniform(1000, 1500, n_samples)
    glcm_contrast = np.random.uniform(0.1, 10, n_samples)
    surface_change = np.random.uniform(-0.5, 0.5, n_samples)
    fracture_density = np.random.uniform(0, 5, n_samples)

    displacement = np.cumsum(np.random.normal(0, 0.01, (n_samples, n_timesteps)), axis=1)
    pore_pressure = np.random.uniform(50, 150, (n_samples, n_timesteps))
    vibration_events = np.random.poisson(1, (n_samples, n_timesteps))

    rainfall_intensity = np.tile(np.random.uniform(0, 50, n_timesteps), (n_samples, 1))
    temperature = np.random.uniform(-5, 25, (n_samples, n_timesteps))
    humidity = np.random.uniform(40, 90, (n_samples, n_timesteps))

    time_since_blast = np.random.uniform(0, 168, n_samples)
    historical_incidents = np.random.poisson(0.1, n_samples)
    equipment_proximity = np.random.uniform(10, 100, n_samples)

    prob_rockfall = (slope / 60 + rainfall_intensity[:, -1] / 50 + np.abs(displacement[:, -1]) / 10 +
                     fracture_density / 5 + historical_incidents) / 5
    prob_rockfall = np.clip(prob_rockfall * 0.1, 0, 1)
    rockfall_event = np.random.binomial(1, prob_rockfall, n_samples)

    spatial_df = pd.DataFrame({
        'cell_id': range(n_samples),
        'x': coords[:, 0], 'y': coords[:, 1],
        'slope': slope, 'aspect': aspect, 'elevation': elevation,
        'glcm_contrast': glcm_contrast, 'surface_change': surface_change,
        'fracture_density': fracture_density,
        'time_since_blast': time_since_blast, 'historical_incidents': historical_incidents,
        'equipment_proximity': equipment_proximity,
        'rockfall_event': rockfall_event
    })

    ts_df = pd.DataFrame({
        'cell_id': np.repeat(range(n_samples), n_timesteps),
        'timestamp': np.tile(pd.date_range(start='2023-01-01', periods=n_timesteps, freq='H'), n_samples),
        'displacement': displacement.ravel(),
        'pore_pressure': pore_pressure.ravel(),
        'vibration_events': vibration_events.ravel(),
        'rainfall_intensity': rainfall_intensity.ravel(),
        'temperature': temperature.ravel(),
        'humidity': humidity.ravel()
    })

    return spatial_df, ts_df

spatial_df, ts_df = simulate_data()
print("Data Simulated: {} spatial cells, {} time-series points".format(len(spatial_df), len(ts_df)))

def engineer_features(spatial_df, ts_df):
    spatial_df = spatial_df.copy()
    spatial_df['slope_deriv'] = np.gradient(spatial_df['slope'].values)[:len(spatial_df)]  # Simple deriv
    spatial_df['rainfall_24h'] = ts_df.groupby('cell_id')['rainfall_intensity'].sum().values
    spatial_df['displacement_rate'] = ts_df.groupby('cell_id')['displacement'].diff().fillna(0).mean()
    spatial_df['pore_grad'] = ts_df.groupby('cell_id')['pore_pressure'].diff().fillna(0).mean()
    spatial_df['vib_freq'] = ts_df.groupby('cell_id')['vibration_events'].sum().values
    spatial_df['temp_range'] = ts_df.groupby('cell_id')['temperature'].max() - ts_df.groupby('cell_id')['temperature'].min()
    spatial_df['humidity_avg'] = ts_df.groupby('cell_id')['humidity'].mean()
    spatial_df['roughness'] = spatial_df['glcm_contrast'] * spatial_df['fracture_density']

    X_spatial = spatial_df.drop(['cell_id', 'x', 'y', 'rockfall_event'], axis=1)
    y = spatial_df['rockfall_event']
    return X_spatial, y, spatial_df

X_spatial, y, spatial_df = engineer_features(spatial_df, ts_df)
print("Features Engineered: {} features".format(X_spatial.shape[1]))
print(spatial_df.head())

# LSTM for Temporal Fusion
def prepare_ts_features(ts_df):
    ts_pivot = ts_df.pivot(index='cell_id', columns='timestamp', values=['displacement', 'rainfall_intensity', 'vibration_events'])
    ts_features = ts_pivot.fillna(0).values.reshape(-1, ts_df['timestamp'].nunique(), 3)
    return ts_features

ts_features = prepare_ts_features(ts_df)

lstm_model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(ts_features.shape[1], ts_features.shape[2])),
    LSTM(50),
    Dense(32, activation='relu'),
    Dense(8)  # 8 temporal features
])
lstm_model.compile(optimizer='adam', loss='mse')
lstm_features = np.random.rand(len(X_spatial), 8)  # Simulated (train on real data in production)
print("LSTM Features: Shape", lstm_features.shape)

# Simulated CNN Features (in production: feed real orthomosaics)
cnn_features = np.random.rand(len(X_spatial), 16)  # 16 spatial features
print("CNN Features: Shape", cnn_features.shape)

# Train with Imbalance Handling
   smote = SMOTE(random_state=42)
   X_res, y_res = smote.fit_resample(X_spatial, y)

   X_train, X_test, y_train, y_test = train_test_split(X_res, y_res, test_size=0.2, random_state=42)

   model = XGBClassifier(n_estimators=100, learning_rate=0.1, max_depth=6, random_state=42)
   model.fit(X_train, y_train)

   y_pred = model.predict(X_test)
   print("Classification Report:\n", classification_report(y_test, y_pred))

   # SHAP Interpretability
   explainer = shap.Explainer(model)
   shap_values = explainer(X_test)
   shap.summary_plot(shap_values, X_test, show=False)
   plt.title("SHAP Feature Importance")
   plt.show()  # Displays inline in Colab

# Predict on New Data (simulate real-time)
X_new = X_spatial.copy()
prob_rockfall = model.predict_proba(X_new)[:, 1]

# Probabilistic Risk Score
def compute_risk_score(prob_rockfall, slope, rainfall, displacement):
    risk = 1 / (1 + np.exp(-(prob_rockfall * 10 + slope/10 + rainfall/5 + displacement/0.1)))
    return np.clip(risk, 0, 1)

risk_scores = compute_risk_score(prob_rockfall, spatial_df['slope'], spatial_df['rainfall_24h'], spatial_df['displacement_rate'])

# ALARP-Based Alerts
def assess_risk_and_alert(prob_rockfall, spatial_df, risk_scores):
    alerts = []
    for idx, row in spatial_df.iterrows():
        risk = risk_scores[idx]
        if risk < 0.001:
            severity, action = "Low Risk (Green)", "Continue operations."
        elif risk < 0.01:
            severity, action = "Moderate Risk (Yellow)", "Increase vigilance."
        elif risk < 0.05:
            severity, action = "High Risk (Orange)", "Prepare evacuation."
        else:
            severity, action = "Imminent Risk (Red)", "Evacuate immediately!"

        if severity != "Low Risk (Green)":
            alerts.append({'cell_id': row['cell_id'], 'x': row['x'], 'y': row['y'],
                           'risk': risk, 'severity': severity, 'action': action})
            print(f"ALERT: Cell {row['cell_id']} ({row['x']:.1f}, {row['y']:.1f}): {severity} - {action} (Risk: {risk:.3f})")

    return alerts

alerts = assess_risk_and_alert(prob_rockfall, spatial_df, risk_scores)
print(f"\nTotal Alerts Generated: {len(alerts)}")

# Risk Map (Interactive Folium)
def create_risk_map(spatial_df, risk_scores):
    m = folium.Map(location=[spatial_df['y'].mean(), spatial_df['x'].mean()], zoom_start=10)
    for idx, row in spatial_df.iterrows():
        risk = risk_scores[idx]
        color = 'green' if risk < 0.001 else 'yellow' if risk < 0.01 else 'orange' if risk < 0.05 else 'red'
        folium.CircleMarker(
            location=[row['y'], row['x']],
            radius=5, popup=f"Cell {row['cell_id']}: Risk {risk:.3f}",
            color=color, fill=True, fillColor=color
        ).add_to(m)
    return m

m = create_risk_map(spatial_df, risk_scores)
m.save('risk_map.html')  # Download this file from Colab (Files tab)
print("Risk Map saved as 'risk_map.html' - Open in browser for interactive view!")
display(m)  # Tries to display in Colab (may need folium's display function)

